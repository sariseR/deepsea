{
  "name": "link",
  "version": "0.1.5",
  "description": "Module runtime and converter for Labeled Modules, CommonJS and AMD.",
  "homepage": "http://github.com/calyptus/link.js",
  "keywords": [
    "util",
    "modules",
    "label",
    "client",
    "browser",
    "amd",
    "commonjs"
  ],
  "author": {
    "name": "Sebastian Markbage",
    "email": "sebastian@calyptus.eu"
  },
  "bugs": {
    "url": "https://github.com/calyptus/link.js/issues"
  },
  "licenses": [
    {
      "type": "BSD-2-Clause",
      "url": "http://raw.github.com/calyptus/link.js/master/LICENSE"
    },
    {
      "type": "MIT",
      "url": "http://raw.github.com/calyptus/link.js/master/LICENSE"
    }
  ],
  "dependencies": {},
  "engines": {
    "node": "> 0.4.x < 0.9.0"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/calyptus/link.js.git"
  },
  "main": "./Source/Node/link.js",
  "bin": {
    "linkjs": "./Source/Node/link.js",
    "link.js": "./Source/Node/link.js"
  },
  "readme": "What is this?\n-------------\n\nLink.js is a module loader and conversion tool. It supports Labeled Modules, CommonJS and Asynchronous Module Definitions (AMD).\n\nLink.js is the first loader to support the Labeled Modules format. It emulates the import and export statements in ECMAScript.next. In Labeled Modules, the labels **require:** and **exports:** can be used to import or export top level variables in a module.\n\n```javascript\nrequire: \"Math\"\n\nfunction length(a, b){\n\treturn abs(a - b);\n}\n\nexports: function area(x1, y1, x2, y2){\n  return length(x1, x2) * length(y1, y2);\n}\n```\n\nThese files are compatible with plain old script tag loading - without bloated boilerplate.\n\n[Read more about this on the Labeled Modules Specification.](http://github.com/labeledmodules/labeled-modules-spec/wiki)\n\n\nHow Do I Run This in the Browser?\n---------------------------------\n\n```html\n<script src=\"Source/Web/link.js\" data-main=\"YourMainModule\"></script>\n```\n\nThe first attribute is the path to link.js and the second is the path to your main module.\n\n\nHow Do I Run This in Node.js?\n-----------------------------\n\nAs a global runtime:\n\n```\nnpm install -g link\n```\n\n```\nlinkjs YourMainModule\n```\n\nOR\n\nAs a local dependency:\n\n```\nnpm install link\n```\n\n```javascript\nrequire('link'); // This will allow future modules to use Link.js\nrequire('YourMainModule');\n```\n\nBy using Link.js as a local dependency you can use it as a loader even if your (or your users') environments don't have Link.js installed globally.\n\n\nHow Do I Convert My Source Files to CommonJS or AMD?\n----------------------------------------------------\n\n```\nnpm install -g link\n```\n\n```\nlinkjs --cjs YourModule > YourModuleForCommonJS.js\n\nlinkjs --amd YourModule > YourModuleForAMD.js\n\nlinkjs -c -a YourModule > YourModuleForCommonJSandAMD.js\n```\n\nLibrary/Link.js\n---------------\n\nThis is a library designed to be embedded by other script loaders or as part of\na plugin to other script loaders. It's purpose is to parse a JavaScript file and\nstatically determine any dependencies.\n\nBeyond recognizing Labeled Modules it also recognizes CommonJS modules and\nAsynchronous Module Definitions (AMD).\n\nIt can also convert these JavaScript files into a format compatible with CommonJS,\nAsynchronous Module Definitions and/or exports to the global object\n\n```javascript\nvar commonJSsource = require('link').parse(source).convert(options);\n```\n\nIn static mode, the imported modules are resolved and global variables are replaced with explicit module properties. I.e:\n\n```javascript\nrequire: \"Math\";\nexports: var x = abs(5);\n```\n\nis resolved to:\n\n```javascript\nvar Math = require('Math');\nexports.x = Math.abs(5);\n```\n\nStatic mode is recommended to generate production ready files. In dynamic mode, the imported variables are determined at runtime using a with statement. Your source code is untouched. This is recommended during development.\n\nSee the source file for additional options.\n\n\nNode/Link.js\n------------\n\nThis is a runtime loader and script conversion tool for Node.js. It can be ran stand-alone but it's recommended that you install it using NPM.\n\n```\nnpm install -g link\n```\n\nYou can use this tool to convert your modules into other module formats or universal module formats. You can target multiple formats in a single file.\n\n```\nUsage:\nlinkjs --output [filename] [--global] [--cjs] [--amd] [--strict] modulename\nlinkjs modulename [argv...]\n\nOptions:\n--output [filename]        Convert the input file to one or more of the formats below.\n                           If no filename is provided, the result is written to stdout.\n[--global] [--cjs] [--amd] Select a target format: the global object, CommonJS or AMD.\n[--strict]                 Enforce dynamic strict mode. Requires ECMAScript 5.\n\n-[o|g|c|a|s]               Single character shortcuts for the above options.\n\nmodulename [argv...]       Run a module in Node.js, with optional arguments.\n```\n\nYou can alternatively use Link.js as a plugin to Node's existing module loader. First, install it as a local dependency.\n\n```\nnpm install link\n```\n\nThen require it at the first line of your application or module.\n\n```javascript\nrequire('link');\n```\n\nAny subsequent calls to require can now use Labeled Modules or AMD syntax. However, the first loaded module can't because the plugin has not been loaded yet. Your entry module should use CommonJS while sub-modules can use Labeled Modules or AMD.\n\n\nWeb/Link.js\n-----------\n\nThis is a script loader for use in the browser environment. It uses Link.js to load, parse and execute scripts in isolated scopes so that there are no conflicts between the files. It supports at least Chrome, Safari, Firefox, Opera and IE6+.\n\nTo load a module using Link.js simply add a script tag to your HTML where the **src** attribute points to link.js and the **data-main** attribute specifies your main module to load.\n\n```html\n<script src=\"link.js\" data-main=\"ApplicationRootModule.js\"></script>\n```\n\nLink.js doesn't normally expose an API to the global object. It can be **required** from within your module though. The exported API is the same as the Module Loader API proposed for [ECMAScript.next](http://wiki.ecmascript.org/doku.php?id=harmony:module_loaders).\n\n\nDebugging\n---------\n\nWeb/Link.js uses XHR to load and parse your code, then it executes it using **eval**.\n\nSome browser tools won't allow debugging of eval:ed code by default. However, Link.js\nuses the `//@ sourceURL=...` convention to enable proper debugging in compatible browsers.\n\nIn Safari 5.1, this feature is broken for JIT:ed code. It's fixed in the nightly builds.\n\nIE and Opera does support debugging of eval:ed code but doesn't give them a proper name in the\nUI. This means breakpoints are not persistent between page reloads. Please bug them until they\nfix this.\n\nA future enhancement of Web/Link.js could load some files that do not conflict in plain\nscript tags.\n\n\nHosting Cross-Domain\n--------------------\n\nIf you're hosting your development source code, you should enable\n[Cross-Origin Resource Sharing](http://www.w3.org/TR/cors/) on your server. This will enable\nfull Link.js support in browsers that support CORS.\n\nIf you're unable to use CORS, you could still load cross-domain modules in legacy mode,\nif they don't share export names. You simply load the modules and any indirect dependencies\nin the right order.\n\nIf you're able to host a HTML file, you could also use an porthole compatible loader, such as\n[Inject](https://github.com/linkedin/inject), that enable cross-domain loading through an\niframe proxy.\n\nIf you're loading from the file:// protocol and XHR is not supported (Chrome), or you wish\nto host your files cross-domain in production, you can use Link.js to convert your\nsource files into Asynchronous Module Definitions (AMD).\n\n\nKnown Issues\n------------\n\nThere are a few very subtle cases where the semantics of Link.js differs from a regular\nprogram. You're very unlikely to hit any of them.\n\n**Deleting a variable** binding is usually a no-op.\n\n```javascript\nvar x = true;\ndelete x;\n```\n\nAfter running this code, **x** should still be **true**. However, Link.js may treats global\nvariables as deletable, so **x** is now **undefined**.\n\nThe solution is to avoid using this in your code. If you do have it, it's probably a bug.\nECMAScript 5 strict mode explicitly forbits deleting variable bindings. A future version of\nLink.js may ignore such delete statements.\n\n**The function declaration** statement is often missunderstood and can lead to\nunexpected behavior.\n\n```javascript\nvar bar = foo;\nfunction foo(){\n\tconsole.log(foo); // \"Bar\"\n}\nfoo = \"Bar\";\nbar();\n```\n\nThis should output \"Bar\" as you might expect. However, Link.js treats exported function\ndeclarations more like this:\n\n```javascript\nvar foo = function foo(){\n\tconsole.log(foo); // function\n};\nvar bar = foo;\nfoo = \"Bar\";\nbar();\n```\n\nThis subtle difference means that `console.log(foo);` no longer refers to the global variable\nbinding `foo` but directly to the function itself. You're very unlikely to hit this issue.\n\nAdditionally, V8 (incorrectly) won't allow labels on function declarations in strict mode.\n\nTo avoid confusion in edge cases, you can use anonymous function expressions syntax for\nexported functions:\n\n```javascript\nexports: var foo = function(){ ... };\n```\n\nThanks\n------\n\nA special thanks to [@dherman](https://github.com/dherman) for coming up with ECMAScript.next modules and with the name Link.js for this library.",
  "readmeFilename": "README.md",
  "_id": "link@0.1.5",
  "dist": {
    "shasum": "6fefada573ca9adc096a8dc9ccd79a5a50bdec4e"
  },
  "_from": "link@",
  "_resolved": "https://registry.npmjs.org/link/-/link-0.1.5.tgz"
}
